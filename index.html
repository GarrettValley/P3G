// Constants for DIN 32711 calculations
const P3G_CONSTANT = 0.25;  // Constant for P3G profile

// DOM Elements
const diameterInput = document.getElementById('nominalDiameter');
const eccentricityInput = document.getElementById('eccentricity');
const profileTypeSelect = document.getElementById('profileType');
const toleranceSelect = document.getElementById('tolerance');
const generateButton = document.getElementById('generateButton');
const meanCircleOutput = document.getElementById('meanCircle');
const outerCircleOutput = document.getElementById('outerCircle');
const innerCircleOutput = document.getElementById('innerCircle');
const profilePath = document.getElementById('profilePath');
const profileSVG = document.getElementById('profileSVG');
const exportDXFButton = document.getElementById('exportDXF');

// Event Listeners
generateButton.addEventListener('click', generateProfile);
exportDXFButton.addEventListener('click', exportDXF);

// Initialize with default values
generateProfile();

// Main function to generate the P3G profile
function generateProfile() {
    const nominalDiameter = parseFloat(diameterInput.value);
    const eccentricity = parseFloat(eccentricityInput.value);
    const profileType = profileTypeSelect.value;
    
    if (isNaN(nominalDiameter) || isNaN(eccentricity)) {
        alert('Please enter valid numerical values');
        return;
    }
    
    // Validate inputs
    if (nominalDiameter < 5 || nominalDiameter > 500) {
        alert('Nominal diameter must be between 5mm and 500mm');
        return;
    }
    
    const recommendedEccMin = 0.008 * nominalDiameter;
    const recommendedEccMax = 0.05 * nominalDiameter;
    
    if (eccentricity < 0.1) {
        alert('Eccentricity must be at least 0.1mm');
        return;
    }
    
    if (eccentricity < recommendedEccMin || eccentricity > recommendedEccMax) {
        if (!confirm(`The eccentricity value is outside the recommended range (${recommendedEccMin.toFixed(2)}mm - ${recommendedEccMax.toFixed(2)}mm). Continue anyway?`)) {
            return;
        }
    }
    
    // Calculate dimensions according to DIN 32711
    const meanCircle = nominalDiameter;
    const innerCircle = nominalDiameter - 2 * eccentricity;
    const outerCircle = nominalDiameter + 2 * eccentricity;
    
    // Update the information display
    meanCircleOutput.textContent = meanCircle.toFixed(3) + ' mm';
    outerCircleOutput.textContent = outerCircle.toFixed(3) + ' mm';
    innerCircleOutput.textContent = innerCircle.toFixed(3) + ' mm';
    
    // Generate the path for the P3G profile
    const path = generateP3GPath(nominalDiameter, eccentricity, profileType);
    profilePath.setAttribute('d', path);
    
    // Adjust viewBox to properly display the profile
    const viewBoxSize = Math.max(outerCircle, outerCircle) + 40; // Increased for dimensions
    profileSVG.setAttribute('viewBox', `-${viewBoxSize/2} -${viewBoxSize/2} ${viewBoxSize} ${viewBoxSize}`);
    
    // Enable export button
    exportDXFButton.disabled = false;
    
    // Add dimensions to the SVG
    addDimensions(nominalDiameter, eccentricity, profileType);
}

// Generate the SVG path for a P3G profile
function generateP3GPath(diameter, eccentricity, type) {
    const radius = diameter / 2;
    const e = eccentricity;
    const points = [];
    const steps = 360;
    
    // Calculate points around the profile
    for (let i = 0; i <= steps; i++) {
        const angle = (i / steps) * 2 * Math.PI;
        
        // P3G profile formula based on DIN 32711
        let r;
        if (type === 'internal') {
            // Internal profile (female)
            r = radius + e * Math.cos(3 * angle);
        } else {
            // External profile (male)
            r = radius - e * Math.cos(3 * angle);
        }
        
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        
        points.push([x, y]);
    }
    
    // Create SVG path command
    let path = `M ${points[0][0]},${points[0][1]}`;
    for (let i = 1; i < points.length; i++) {
        path += ` L ${points[i][0]},${points[i][1]}`;
    }
    path += ' Z';  // Close the path
    
    return path;
}

// Function to add dimensions to the SVG
function addDimensions(diameter, eccentricity, profileType) {
    // Remove any existing dimension elements
    const existingDimensions = document.querySelectorAll('.dimension');
    existingDimensions.forEach(el => el.remove());
    
    const radius = diameter / 2;
    const innerRadius = radius - eccentricity;
    const outerRadius = radius + eccentricity;
    
    // Create a group for dimensions
    const dimensionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    dimensionGroup.setAttribute('class', 'dimension');
    
    // Add reference circles
    const referenceCircles = document.createElementNS("http://www.w3.org/2000/svg", "g");
    
    // Mean circle (nominal diameter)
    const meanCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    meanCircle.setAttribute('cx', '0');
    meanCircle.setAttribute('cy', '0');
    meanCircle.setAttribute('r', radius);
    meanCircle.setAttribute('fill', 'none');
    meanCircle.setAttribute('stroke', '#a3a3a3');
    meanCircle.setAttribute('stroke-width', '0.3');
    meanCircle.setAttribute('stroke-dasharray', '2 1');
    referenceCircles.appendChild(meanCircle);
    
    // Inner circle
    const innerCircleEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    innerCircleEl.setAttribute('cx', '0');
    innerCircleEl.setAttribute('cy', '0');
    innerCircleEl.setAttribute('r', innerRadius);
    innerCircleEl.setAttribute('fill', 'none');
    innerCircleEl.setAttribute('stroke', '#a3a3a3');
    innerCircleEl.setAttribute('stroke-width', '0.3');
    innerCircleEl.setAttribute('stroke-dasharray', '2 1');
    referenceCircles.appendChild(innerCircleEl);
    
    // Outer circle
    const outerCircleEl = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    outerCircleEl.setAttribute('cx', '0');
    outerCircleEl.setAttribute('cy', '0');
    outerCircleEl.setAttribute('r', outerRadius);
    outerCircleEl.setAttribute('fill', 'none');
    outerCircleEl.setAttribute('stroke', '#a3a3a3');
    outerCircleEl.setAttribute('stroke-width', '0.3');
    outerCircleEl.setAttribute('stroke-dasharray', '2 1');
    referenceCircles.appendChild(outerCircleEl);
    
    dimensionGroup.appendChild(referenceCircles);
    
    // Add dimension lines and labels
    const dimensionLines = document.createElementNS("http://www.w3.org/2000/svg", "g");
    
    // Diameter dimension (horizontal)
    const diaLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    diaLine.setAttribute('x1', -radius);
    diaLine.setAttribute('y1', radius + 10);
    diaLine.setAttribute('x2', radius);
    diaLine.setAttribute('y2', radius + 10);
    diaLine.setAttribute('stroke', '#64748b');
    diaLine.setAttribute('stroke-width', '0.5');
    dimensionLines.appendChild(diaLine);
    
    // Add arrowheads
    const leftArrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    leftArrow.setAttribute('d', `M ${-radius} ${radius + 10} L ${-radius + 3} ${radius + 8} L ${-radius + 3} ${radius + 12} Z`);
    leftArrow.setAttribute('fill', '#64748b');
    dimensionLines.appendChild(leftArrow);
    
    const rightArrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    rightArrow.setAttribute('d', `M ${radius} ${radius + 10} L ${radius - 3} ${radius + 8} L ${radius - 3} ${radius + 12} Z`);
    rightArrow.setAttribute('fill', '#64748b');
    dimensionLines.appendChild(rightArrow);
    
    // Diameter label
    const diaLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    diaLabel.setAttribute('x', '0');
    diaLabel.setAttribute('y', radius + 18);
    diaLabel.setAttribute('text-anchor', 'middle');
    diaLabel.setAttribute('font-size', '4');
    diaLabel.setAttribute('fill', '#64748b');
    diaLabel.textContent = `Ã˜${diameter.toFixed(2)}`;
    dimensionLines.appendChild(diaLabel);
    
    // Eccentricity dimension
    const eccLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    eccLine.setAttribute('x1', radius);
    eccLine.setAttribute('y1', 0);
    eccLine.setAttribute('x2', outerRadius);
    eccLine.setAttribute('y2', 0);
    eccLine.setAttribute('stroke', '#64748b');
    eccLine.setAttribute('stroke-width', '0.5');
    dimensionLines.appendChild(eccLine);
    
    // Eccentricity label
    const eccLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    eccLabel.setAttribute('x', radius + eccentricity/2);
    eccLabel.setAttribute('y', -3);
    eccLabel.setAttribute('text-anchor', 'middle');
    eccLabel.setAttribute('font-size', '4');
    eccLabel.setAttribute('fill', '#64748b');
    eccLabel.textContent = `e=${eccentricity.toFixed(2)}`;
    dimensionLines.appendChild(eccLabel);
    
    // Add center cross
    const centerHLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    centerHLine.setAttribute('x1', -4);
    centerHLine.setAttribute('y1', 0);
    centerHLine.setAttribute('x2', 4);
    centerHLine.setAttribute('y2', 0);
    centerHLine.setAttribute('stroke', '#64748b');
    centerHLine.setAttribute('stroke-width', '0.5');
    dimensionLines.appendChild(centerHLine);
    
    const centerVLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    centerVLine.setAttribute('x1', 0);
    centerVLine.setAttribute('y1', -4);
    centerVLine.setAttribute('x2', 0);
    centerVLine.setAttribute('y2', 4);
    centerVLine.setAttribute('stroke', '#64748b');
    centerVLine.setAttribute('stroke-width', '0.5');
    dimensionLines.appendChild(centerVLine);
    
    // Profile type label
    const profileLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    profileLabel.setAttribute('x', 0);
    profileLabel.setAttribute('y', -radius - 12);
    profileLabel.setAttribute('text-anchor', 'middle');
    profileLabel.setAttribute('font-size', '5');
    profileLabel.setAttribute('font-weight', 'bold');
    profileLabel.setAttribute('fill', '#2563eb');
    profileLabel.textContent = profileType === 'internal' ? 'Internal P3G (Female)' : 'External P3G (Male)';
    dimensionLines.appendChild(profileLabel);
    
    dimensionGroup.appendChild(dimensionLines);
    
    // Append the dimension group to the SVG
    profileSVG.appendChild(dimensionGroup);
}

// Calculate points for the P3G profile
function calculateP3GPoints(diameter, eccentricity, type, steps = 360) {
    const radius = diameter / 2;
    const e = eccentricity;
    const points = [];
    
    // Calculate points around the profile
    for (let i = 0; i <= steps; i++) {
        const angle = (i / steps) * 2 * Math.PI;
        
        // P3G profile formula based on DIN 32711
        let r;
        if (type === 'internal') {
            // Internal profile (female)
            r = radius + e * Math.cos(3 * angle);
        } else {
            // External profile (male)
            r = radius - e * Math.cos(3 * angle);
        }
        
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        
        points.push([x, y]);
    }
    
    return points;
}

// Custom DXF generator implementation
function createDXF(points) {
    // DXF header
    let dxf = '0\nSECTION\n';
    dxf += '2\nHEADER\n';
    dxf += '0\nENDSEC\n';
    
    // Tables section (containing layer definition)
    dxf += '0\nSECTION\n';
    dxf += '2\nTABLES\n';
    
    // Layer table
    dxf += '0\nTABLE\n';
    dxf += '2\nLAYER\n';
    dxf += '0\nLAYER\n';
    dxf += '2\nP3G_Profile\n';  // Layer name
    dxf += '70\n0\n';
    dxf += '62\n5\n';  // Color: blue
    dxf += '6\nCONTINUOUS\n';  // Linetype
    dxf += '0\nENDTAB\n';
    
    dxf += '0\nENDSEC\n';
    
    // Entities section (containing the polyline)
    dxf += '0\nSECTION\n';
    dxf += '2\nENTITIES\n';
    
    // POLYLINE entity
    dxf += '0\nPOLYLINE\n';
    dxf += '8\nP3G_Profile\n';  // Layer name
    dxf += '66\n1\n';  // Vertices follow flag
    dxf += '70\n1\n';  // Closed polyline flag
    
    // Add vertices
    for (let i = 0; i < points.length; i++) {
        dxf += '0\nVERTEX\n';
        dxf += '8\nP3G_Profile\n';
        dxf += '10\n' + points[i][0].toFixed(6) + '\n';  // X
        dxf += '20\n' + points[i][1].toFixed(6) + '\n';  // Y
        dxf += '30\n0.0\n';  // Z
    }
    
    // End of polyline
    dxf += '0\nSEQEND\n';
    
    // End of entities
    dxf += '0\nENDSEC\n';
    
    // EOF
    dxf += '0\nEOF';
    
    return dxf;
}

// Function to export the profile in DXF format
function exportDXF() {
    try {
        const nominalDiameter = parseFloat(diameterInput.value);
        const eccentricity = parseFloat(eccentricityInput.value);
        const profileType = profileTypeSelect.value;
        
        // Calculate the profile points
        const points = calculateP3GPoints(nominalDiameter, eccentricity, profileType);
        
        // Generate the DXF content using our custom function
        const dxfString = createDXF(points);
        
        // Create a file from the DXF string
        const blob = new Blob([dxfString], { type: 'application/dxf' });
        
        // Create a download link
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `P3G_${profileType}_D${nominalDiameter}_e${eccentricity}.dxf`;
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log("DXF export completed successfully");
    } catch (error) {
        console.error('Error generating DXF:', error);
        alert('Error generating DXF file. See console for details.');
    }
}
